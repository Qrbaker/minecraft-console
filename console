#!/bin/bash

VERSION="6.0"

USERNAME=$(whoami)

CONFIG_FILE="/home/$USERNAME/.config/java_console.config"

# Make sure the script is not running as root
if [ "$UID" == "0" ]; then
    echo -n "WARNING ! For security reasons: DO NOT RUN THE SERVER AS ROOT "
    c=1
    while [ "$c" -le 5 ]; do
        echo -n "!"
        sleep 1
        ((c = c + 1))
    done
    echo ""
    exit 1
fi
        
# Functions
find_jar() {
    # Search for the jar file to run if one was not specified in the profile
    JARNAME=$(find "${SERVERPATH}/" -maxdepth 1 -name "minecraft*.jar" -type f -printf "%f\n")
}

send_server() {
    # Sends the contents to the screen and executes it
    screen -p 0 -S "$PROFILE" -X stuff "$*$(printf \\r)"
}

is_running() {
    # Checks for the screen running the server
    return $( pgrep -u "$USERNAME" -f "SCREEN -dmS ${PROFILE}" > /dev/null )
}

check_config() {
    # Scrict is if we need the files to exist already or not.
    if [ -z "$TIME" ]; then
        echo "Default TIME is not set: \"$TIME\""
    elif [ -n "$PLAYERLISTPATH" ] && [ ! -d "$PLAYERLISTPATH" ]; then
        echo "PLAYERLISTPATH does not exist: \"$PLAYERLISTPATH\""
    elif [ "$TYPE" != "minecraft" ]; then
        echo "Profile $PROFILE has unsupported TYPE of \"$TYPE\""
    elif [ "$AUTOSTART" != "true" ] && [ "$AUTOSTART" != "false" ]; then
        echo "Profile $PROFILE has unsupported AUTOSTART of \"$AUTOSTART\""
    elif [ -z "$SERVERPATH" ]; then
        echo "Profile $PROFILE has blank SERVERPATH: \"$SERVERPATH\""
    elif [ ! -d "$SERVERPATH" ]; then
        echo "Profile $PROFILE has SERVERPATH that does not exist: \"$SERVERPATH\""
    elif [ ! -r "$SERVERPATH" ]; then
        echo "Profile $PROFILE has SERVERPATH that is not readable: \"$SERVERPATH\""
    elif [ ! -w "$SERVERPATH" ]; then
        echo "Profile $PROFILE has SERVERPATH that is not writeable: \"$SERVERPATH\""
    elif [ -z "$COMMAND" ]; then
        echo "Profile $PROFILE has blank COMMAND: \"$COMMAND\""
    elif [ "$UPDATEABLE" != "true" ] && [ "$UPDATEABLE" != "vanilla" ] && [ "$UPDATEABLE" != "snapshot" ] && [ "$UPDATEABLE" != "false" ]; then
        echo "Profile $PROFILE has unsupported UPDATEABLE of \"$UPDATEABLE\""

    elif [ "$1" == "strict" ]; then
        if [ ! -d "${SERVERPATH}/${WORLD}" ]; then
            echo "Profile $PROFILE has WORLD that does not exist: \"$WORLD\""
        elif [ -z "$JARNAME" ]; then
            echo "Profile $PROFILE has blank JARNAME: \"$JARNAME\""
        elif [ ! -f "${SERVERPATH}/${JARNAME}" ]; then
            echo "Profile $PROFILE has JARNAME that does not exist: \"$JARNAME\""
        elif [ ! -r "${SERVERPATH}/${JARNAME}" ]; then
            echo "Profile $PROFILE has JARNAME that is not readable: \"$JARNAME\""
        elif [ ! -w "${SERVERPATH}/${JARNAME}" ]; then
            echo "Profile $PROFILE has JARNAME that is not writeable: \"$JARNAME\""
        else
            return 0
        fi
    else
        # All good
        return 0
    fi
    exit 3
}

start() {
    if is_running; then
        echo "The $PROFILE server is already running, try restart or stop"
        return 1
    fi
    
    # Check if this profile is allowed to be autorun
    if [ "$1" == "auto" ] && [ "$AUTOSTART" == "false" ]; then
        echo "The $PROFILE server is not set to be autorun. Server not started"
        return 0
    fi
    
    cd "${SERVERPATH}"
    if [ "${TYPE}" == "minecraft" ]; then
        # Copy the server.properties file from the world folder to allow for multiple world configurations
        if [ -e "$WORLD"/server.properties ]; then
            cp -f "$WORLD"/server.properties server.properties
        fi
    fi
    
    if [ -d "$PLAYERLISTPATH" ]; then
        if [ "$TYPE" == "minecraft" ]; then
            ln -f "$PLAYERLISTPATH"/minecraft.whitelist "$SERVERPATH"/whitelist.json
            ln -f "$PLAYERLISTPATH"/minecraft.oplist "$SERVERPATH"/ops.json
            ln -f "$PLAYERLISTPATH"/minecraft.banlist "$SERVERPATH"/banned-players.json
        fi
    fi
    
    echo "Starting the $PROFILE server..."
    if [ ! -x "$JARNAME" ]; then
        echo "$JARNAME is not executable, trying to set it"
        chmod +x "$JARNAME"
    fi
    if [ ! -x "$JARNAME" ]; then  
        echo "$JARNAME is not exectuable, cannot start the server"
    fi
    
    # Launch it
    if [ "$1" == "debug" ]; then
        # Launch without screen for easier debugging
        $COMMAND
    else
        screen -dmS "$PROFILE" $COMMAND &
        echo "$PROFILE server launched..."
        # Make sure it is running
        sleep 2
        if is_running; then
            echo "$PROFILE server started."
        else
            echo "$PROFILE server seemes to have crashed!"
        fi
    fi
}

stop() {
    if ! is_running; then
        echo "The $PROFILE server is not running."
        return 0
    fi
    
    echo "Sending stop warnings on the $PROFILE server"
    
    # Test if time parameter was specified
    if [ -n "$1" ]; then
        if [ "$1" -gt 0 ]; then
            TIME="$1"
        fi
    fi
    
    if [ "$TYPE" == "minecraft" ]; then
        send_server "say SERVER STOPPING/RESTARTING IN $TIME SECONDS"
        sync
        sleep "$TIME"
        send_server "stop"
    fi
    
    echo -n "Stopping the $PROFILE server"
    i=1
    while [ "$i" -le 20 ]; do
        if is_running; then
            echo -n "."
            sleep 1
        else
            break
        fi
        i=$((++i)) 
    done
    echo "."
    if is_running; then
        echo "Server is not shutting down cleanly."
        return 1
    fi
    
    echo "Done."
}

status() {
    if is_running; then
        echo "$PROFILE server is running"
    else
        echo "$PROFILE server is shut down"
    fi
}

backup() {
    hash rsync 2>/dev/null || { echo "I need rsync but it's not installed"; exit 1; }
    
    if [ -z "$BACKUPPATH" ]; then
        echo "Backups are disabled for the $PROFILE profile."
        echo "Update the profile if you want to make backups."
        return 2
    elif ! is_running && echo "$1" | grep -Eivq "(force|f|-f|override)"; then
        echo "The $PROFILE server is not running, so no backups need to be made."
        return 0
    else
        echo "Backing up the $PROFILE server..."
    fi
    
    if [ ! -d "$BACKUPPATH" ]; then
        echo "The backup path $BACKUPPATH for the profile $PROFILE does not exist!"
        echo "Creating it now..."
        mkdir "$BACKUPPATH"
    fi 
    
    if is_running; then
        echo "Suspending saves on the $PROFILE server..."
        if [ "$TYPE" == "minecraft" ]; then
            send_server "say SERVER BACKUP STARTING"
            send_server "save-off"
            send_server "save-all"
        fi
        sleep 2
        sync
        sleep 1
    fi
    
    echo "Making the backup..."
    DATE=$(date "+%Y-%m-%dT%H:%M:%S")
    
    if [ -L "${BACKUPPATH}/current" ] && [ -e "${BACKUPPATH}/current" ]; then
        echo "Symlink found; making a diff backup"
        rsync -a --link-dest="${BACKUPPATH}/current" "${SERVERPATH}/" "${BACKUPPATH}/back-${DATE}"
        rm "${BACKUPPATH}/current"
    else
        echo "No symlink found; making a clean backup"
        rsync -a "${SERVERPATH}/" "${BACKUPPATH}/back-${DATE}"
    fi
    
    ln -s "${BACKUPPATH}/back-${DATE}" "${BACKUPPATH}/current"
    
    echo "Backup finished"
    
    if is_running; then
        echo "Re-enabling saves"
        if [ "$TYPE" == "minecraft" ]; then
            send_server "save-on"
            send_server "say SERVER BACKUP ENDED"
        fi
    fi
    
    echo "Done."
}

say() {
    if ! is_running; then
        echo "The $PROFILE server is not running."
        return 2
    fi
    if [ "$TYPE" == "minecraft" ]; then
        send_server "say $*"
    fi
}

command() {
    if ! is_running; then
        echo "The $PROFILE server is not running."
        return 2
    fi
    send_server "$*"
}

update() {
    if [ "$UPDATEABLE" == "false" ]; then
        echo "The $PROFILE server is not set as updateable"
        return 1
    fi
    
    if [ "$TYPE" == "minecraft" ]; then
        # Allow for specifiying a specific version
        if [ -n "$1" ]; then
            CURRENT_VERSION="$1"
        elif [ "$UPDATEABLE" == "vanilla" ]; then
            # Awkward pieces of code that strip the current Minecraft versions from the version file
            CURRENT_VERSION=$(wget -q -O - https://s3.amazonaws.com/Minecraft.Download/versions/versions.json |
                                grep "\"release\":" |
                                sed 's/    "release": "\([0-9a-zA-Z.-]\+\)"/\1/' |
                                tr -d '[:space:]')
            echo "The newest stable version is ${CURRENT_VERSION}"
        elif [ "$UPDATEABLE" == "snapshot" ]; then
            CURRENT_VERSION=$(wget -q -O - https://s3.amazonaws.com/Minecraft.Download/versions/versions.json |
                                grep "\"snapshot\":" |
                                sed 's/    "snapshot": "\([0-9a-zA-Z.-]\+\)",/\1/' |
                                tr -d '[:space:]')
            echo "The newest snapshot is ${CURRENT_VERSION}"
        else
            echo "Unsupported type of Minecraft release. Please fix this profile"
            return 1
        fi
        
        # Parse the version out of the jar file
        INSTALLED_VERSION=$(echo "$JARNAME" |
                            sed 's/minecraft_server.\([0-9a-zA-Z.-]\+\).jar/\1/' |
                            tr -d '[:space:]')
        if [ -n "$INSTALLED_VERSION" ]; then
            echo "Your version is $INSTALLED_VERSION"
        fi
        
        # Check if the current version is outdated
        if [ "${CURRENT_VERSION}" == "${INSTALLED_VERSION}" ]; then
            echo "The $PROFILE server is up to date"
        else
            if is_running; then
                echo "The $PROFILE server is currently running"
                echo -n "Would you like to restart, backup, and update the $PROFILE server? [y|N]: "
            else
                echo -n "Would you like to backup and update the $PROFILE server? [y|N]: "
            fi
            
            read -r VALUE
            while :; do
                case "$VALUE" in
                    y|yes|Y)
                        if is_running; then
                            stop || { echo "Server won't shutdown. Aborting."; return 2; }
                            WASRUNNING="true"
                        fi
                        cd "$SERVERPATH"
                        
                        echo "Backing up..."
                        backup force || { echo "Backup failed! Quitting..."; return 2; }
                       
                        echo "Updating..."
                        wget "https://s3.amazonaws.com/Minecraft.Download/versions/${CURRENT_VERSION}/minecraft_server.${CURRENT_VERSION}.jar" || 
                            {   echo "Download failed, aborting"
                                if [ "$WASRUNNING" == "true" ]; then
                                    start || { echo "Server won't start back up!"; return 2; }
                                fi
                                return 1; }
                        chmod +x "minecraft_server.${CURRENT_VERSION}.jar"
                        if [ -f "$JARNAME" ]; then
                            rm "$JARNAME"
                        fi
                        if [ ! -d "${SERVERPATH}/${WORLD}" ]; then
                            mkdir "${SERVERPATH}/${WORLD}"
                        fi
                        echo "The $PROFILE server was updated to version $CURRENT_VERSION"
                        
                        if [ "$WASRUNNING" == "true" ]; then
                            start || return 1
                        fi
                        return 0
                    ;;
                    n|no|N)
                        echo "Exiting on user command"
                        return 0
                    ;;
                    *)
                        echo -n "Please enter [y|N]: "
                        read -r VALUE
                esac
            done
        fi
    fi
}

list() {
    echo "Profile list:"
    for PROFILE in "${PROFILE_LIST[@]}"; do
        echo -n "${PROFILE} "
    done
    echo ""
}

see() {
    if ! is_running; then
        echo "The $PROFILE server is not running."
        return 1
    fi

    cat > /tmp/screenconfig <<EOF
startup_message off
screen -t 'console' sh -c "tail -n 64 --follow=name ${SERVERPATH}/logs/latest.log"
screen -t 'shell' bash -c "$0 shell $PROFILE"
split
focus down
select 'shell'
resize 3
focus up
select 'console'
focus down
EOF
    screen -S "${PROFILE}-console" -c /tmp/screenconfig
    rm /tmp/screenconfig
    screen -S "${PROFILE}-console" -X quit >& /dev/null
}

shell() {
    MODE="command"
    while :; do
        if [ "$MODE" == "command" ]; then
            echo -n "c "
        else
            echo -n "s "
        fi
        echo -n "> "
        read -r VALUE
        set -- $VALUE
        case "$1" in
            exit|:q|quit)
                screen -S "${PROFILE}-console" -X quit >& /dev/null
                return 0
            ;;
            nick)
                shift 1
                NICK="$*"
            ;;
            help)
                echo "c|s|exit|nick|help"
            ;;
            c|command)
                shift 1
                # Only send something if line is not blank
                if [ -n "$*" ]; then
                    send_server "$*"
                fi
                MODE="command"
            ;;
            s|say|chat)
                shift 1
                MODE="say"
            ;&
            *)
                # Only send something if line is not blank
                if [ -n "$*" ]; then
                    if [ "$MODE" == "command" ]; then
                        send_server "$*"
                    else
                        if [ -n "$NICK" ]; then
                            send_server "say <${NICK}> $*"
                        else
                            send_server "say $*"
                        fi
                    fi
                fi
        esac
    done
}

new() {
    # Add new profile to config
    if [ ! "$1" ] || [ "$1" == "minecraft" ] || [ "$1" == "vanilla" ]; then
        cat >> "${CONFIG_FILE}" <<'endofconfig'
vanilla() {
    TYPE="minecraft"
    AUTOSTART="true"
    SERVERPATH="/home/$USERNAME/${PROFILE}Minecraft"
    BACKUPPATH="/home/$USERNAME/backup/${PROFILE}Minecraft"
    WORLD="world"
    find_jar
    COMMAND="${JAVA} -Xincgc -Xmx4G -Xms2G -jar $JARNAME nogui"
    UPDATEABLE="vanilla"
}

endofconfig
        echo "New vanilla minecraft profile added."
    elif [ "$1" == "modded" ]; then
        cat >> "${CONFIG_FILE}" <<'endofconfig'
modded() {
    TYPE="minecraft"
    AUTOSTART="false"
    SERVERPATH="/home/$USERNAME/${PROFILE}Minecraft"
    BACKUPPATH="/home/$USERNAME/backup/${PROFILE}Minecraft"
    WORLD="world"
    find_jar
    COMMAND="${JAVA} -Xincgc -Xmx4G -Xms2G -cp $JARNAME cpw.mods.fml.relauncher.ServerLaunchWrapper nogui"
    UPDATEABLE="false"
}

endofconfig
        echo "New modded minecraft profile added."
    else
        echo "Unknown profile type ${1}."
        return 1
    fi
    echo "Add the new profile to the profile list to activate it."
}

config() {
    # Make sure GNU screen is installed
    hash screen 2>/dev/null || { echo >&2 "I need screen but it's not installed"; exit 1; }
    
    if [ ! -d "/home/$USERNAME/.config" ]; then
        mkdir "/home/$USERNAME/.config"
    fi
    if ! [ -e "${CONFIG_FILE}" ]; then
        touch "${CONFIG_FILE}"
        cat > "${CONFIG_FILE}" <<'endofconfig'
# Default time for stopping and restarting
TIME=5

# Location of the universal whitelist/oplist. Leave blank if you want to use seperate
# ones for each server.
PLAYERLISTPATH="/home/$USERNAME"

# The java binary to use. Set this if the default java ("which java") isn't what you want to
# run the servers.
JAVA="java"

# Profiles
# To make your own, run "console new <type>"
# Exceptable profiles types are "minecraft", for now.
# To disable backups, leave the BACKUPPATH blank, eg: =""
# UPDATEABLE can equal types "vanilla" or "snapshot" for minecraft.
# "false" will disable updating.
# find_jar is a search that finds the minecraft jar file in the server folder, allowing for updates
# without changing this config file. If there is more than one minecraft jar file in the folder
# the search will fail

# The list of servers that the "all" commands will use
PROFILE_LIST=()

endofconfig
        echo "Base config created. Run \"$0 new <type>\" to add your first profile."
        return 0
    fi
    
    if [ -z "$EDITOR" ]; then
        vi "$CONFIG_FILE" || return $?
    else
        "$EDITOR" "$CONFIG_FILE" || return $?
    fi
    
    # Load the configuration to check it
    echo "Checking new config..."
    source "$CONFIG_FILE"
    
    for PROFILE in "${PROFILE_LIST[@]}"; do
        $PROFILE >& /dev/null || { echo "Profile ${PROFILE} was not found, but it was in the profile list."; return 1; }
        check_config
    done
    echo "Config looks good."
}

help_text() {
    # Help text
    echo "Java server script version $VERSION by Rycieos"
    echo "Usage: $0 [start|stop|restart|try-restart|backup|say|command|status|update|see|list|config|new] <profile-name>|all "
    echo "Profile settings are at ~/.config/java_console.config. Use $0 config to edit"
    exit 1
}

load_profile() {
    if [ -z "$PROFILE" ]; then
        echo "No Profile specified"
        help_text
    fi
    # Load the profile's settings by calling it as a function
    $PROFILE >& /dev/null || { echo "Profile ${PROFILE} was not found. Run \"$0 new <type>\" to add it"; exit 1; }
    check_config "$1"
}

# SCRIPT START

SWITCH="$1"

if [ ! -e "${CONFIG_FILE}" ] && [ "$1" != "config" ]; then
    echo "No config file was found!"
    echo "Please run \"$0 config\""
    exit 1
elif [ "$SWITCH" != "config" ] && [ "$SWITCH" != "new" ] && [ "$SWITCH" != "add" ]; then
    # Load the configuration only if we aren't trying to change it
    source "$CONFIG_FILE"
fi

if [ "$2" == "all" ]; then
    case "$SWITCH" in
        start|s)
            for PROFILE in "${PROFILE_LIST[@]}"; do
                load_profile strict
                start auto
            done
            exit 0
        ;;
        stop|restart|backup|say|command)
            # Shift to get rid of the <command> all. The remainder gets run
            shift 2
            for PROFILE in "${PROFILE_LIST[@]}"; do
                load_profile strict
                "$SWITCH" "$@"
            done
            exit 0
        ;;
        status|update)
            # Shift to get rid of the <command> all. The remainder gets run
            shift 2
            for PROFILE in "${PROFILE_LIST[@]}"; do
                load_profile
                "$SWITCH" "$@"
            done
            exit 0
        ;;
        see|console)
            echo "$1 is not supported for all profiles at the same time."
            exit 3
        ;;
        config|new|add)
            echo "all is implied for ${1}."
            exit 3
        ;;
    esac
fi

PROFILE="$2"

case "$SWITCH" in
    start)
        load_profile strict
        start "$3"
        exit $?
    ;;
    stop)
        load_profile strict
        stop "$3"
        exit $?
    ;;
    restart)
        load_profile strict
        stop "$3"
        start "$3"
        exit $?
    ;;
    try-restart)
        load_profile strict
        if is_running; then
            stop "$3" && start "$3"
            exit $?
        fi
    ;;
    status)
        load_profile
        status
    ;;
    backup)
        load_profile strict
        backup "$3"
        exit $?
    ;;
    say)
        load_profile strict
        shift 2
        say "$*"
        exit $?
    ;;
    command)
        load_profile strict
        shift 2
        command "$*"
        exit $?
    ;;
    update)
        load_profile
        update "$3"
        exit $?
    ;;
    see|console)
        load_profile strict
        see
        exit $?
    ;;
    shell)
        load_profile
        shell
        exit $?
    ;;
    # Profile agnostic
    list)
        list
    ;;
    new)
        new "$2"
        exit $?
    ;;
    config)
        config
        exit $?
    ;;
    *)
        help_text
esac
