#!/bin/bash

VERSION="6.0"
USERNAME=$(whoami)
CONFIG_FILE="/home/${USERNAME}/.config/minecraft-console.config"

# Make sure the script is not running as root
if [ "$UID" == "0" ]; then
    echo -n "WARNING ! For security reasons: DO NOT RUN THE SERVER AS ROOT "
    c=1
    while [ "$c" -le 5 ]; do
        echo -n "!"
        sleep 1
        ((c = c + 1))
    done
    echo ""
    exit 1
fi

# Functions
defaults() {
    # Default server path is in the root
    server_path="${server_root}/${profile}"
    # Default java
    java="java"
    # Default time
    default_time=5
}

find_jar() {
    # Search for the jar file to run if one was not specified in the profile
    jar_name=$(find "${server_path}/" -maxdepth 1 -name "minecraft*.jar" -type f -printf "%f\n")
}

send_server() {
    # Sends the contents to the screen and executes it
    screen -p 0 -S "${profile}" -X stuff "$*$(printf \\r)"
}

is_running() {
    # Checks for the screen running the server
    return $( pgrep -u "${USERNAME}" -f "SCREEN -dmS ${profile}" > /dev/null )
}

check_config() {
    # Scrict is if we need the files to exist already or not.
    if [ -z "${default_time}" ]; then
        echo "'default_time' is not set: '${default_time}'"
    elif [ -n "${player_list_path}" ] && [ ! -d "${player_list_path}" ]; then
        echo "'player_list_path' does not exist: '${player_list_path}'"
    elif [ "${type}" != "minecraft" ]; then
        echo "Profile ${profile} has unsupported 'type' of '${type}'"
    elif [ "${autostart}" != "true" ] && [ "${autostart}" != "false" ]; then
        echo "Profile ${profile} has unsupported 'autostart' of '${autostart}'"
    elif [ -z "${server_path}" ]; then
        echo "Profile ${profile} has blank 'server_path': '${server_path}'"
    elif [ ! -d "${server_path}" ]; then
        echo "Profile ${profile} has 'server_path' that does not exist: '${server_path}'"
    elif [ ! -r "${server_path}" ]; then
        echo "Profile ${profile} has 'server_path' that is not readable: '${server_path}'"
    elif [ ! -w "${server_path}" ]; then
        echo "Profile ${profile} has 'server_path' that is not writeable: '${server_path}'"
    elif [ -z "${server_command}" ]; then
        echo "Profile ${profile} has blank 'server_command': '${server_command}'"
    elif [ "${updateable}" != "vanilla" ] && [ "${updateable}" != "snapshot" ] && [ "${updateable}" != "false" ]; then
        echo "Profile ${profile} has unsupported 'updateable' of '${updateable}'"
    
    elif [ "$1" == "strict" ]; then
        if [ ! -d "${server_path}/${world}" ]; then
            echo "Profile ${profile} has 'world' that does not exist: '${world}'"
            echo "Is it possible that the server is empty and needs to be updated?"
        elif [ -z "${jar_name}" ]; then
            echo "Profile ${profile} has blank 'jar_name': '${jar_name}'"
        elif [ ! -f "${server_path}/${jar_name}" ]; then
            echo "Profile ${profile} has 'jar_name' that does not exist: '${jar_name}'"
        elif [ ! -r "${server_path}/${jar_name}" ]; then
            echo "Profile ${profile} has 'jar_name' that is not readable: '${jar_name}'"
        elif [ ! -w "${server_path}/${jar_name}" ]; then
            echo "Profile ${profile} has 'jar_name' that is not writeable: '${jar_name}'"
        else
            return 0
        fi
    else
        # All good
        return 0
    fi
    exit 3
}

start() {
    if is_running; then
        echo "The ${profile} server is already running, use restart, try-restart, or stop"
        return 1
    fi
    
    # Check if this profile is allowed to be autorun
    if [ "$1" == "auto" ] && [ "${autostart}" == "false" ]; then
        echo "The ${profile} server is not set to be autorun. Server not started"
        return 0
    fi
    
    cd "${server_path}"
    if [ "${type}" == "minecraft" ]; then
        # Copy the server.properties file from the world folder to allow for multiple world configurations
        if [ -e "${world}"/server.properties ]; then
            cp -f "${world}"/server.properties server.properties
        fi
    fi
    
    if [ -d "${player_list_path}" ]; then
        if [ "${type}" == "minecraft" ]; then
            ln -f "${player_list_path}"/minecraft.whitelist "${server_path}"/whitelist.json
            ln -f "${player_list_path}"/minecraft.oplist "${server_path}"/ops.json
            ln -f "${player_list_path}"/minecraft.banlist "${server_path}"/banned-players.json
        fi
    fi
    
    if [ "${eula}" == "true" ]; then
        echo "eula=true" > "${server_path}/eula.txt"
    fi
    
    echo "Starting the ${profile} server..."
    if [ ! -x "${jar_name}" ]; then
        echo "${jar_name} is not executable, trying to set it"
        chmod +x "${jar_name}"
    fi
    if [ ! -x "${jar_name}" ]; then
        echo "${jar_name} is not exectuable, cannot start the server"
        return 1
    fi
    
    # Launch it
    if [ "$1" == "debug" ]; then
        # Launch without screen for easier debugging
        ${server_command}
    else
        screen -dmS "${profile}" ${server_command} &
        echo "${profile} server launched..."
        # Make sure it is running
        sleep 2
        if is_running; then
            echo "${profile} server started."
            # Start the listener if needed
            if [ "${listener}" == "true" ]; then
                listener-start
            fi
        else
            echo "${profile} server seemes to have crashed!"
        fi
    fi
}

stop() {
    if ! is_running; then
        echo "The ${profile} server is not running."
        return 0
    fi
    
    echo "Sending stop warnings on the ${profile} server"
    
    # Test if time parameter was specified
    if [ -n "$1" ]; then
        if [ "$1" -gt 0 ]; then
            default_time="$1"
        fi
    fi
    
    if [ "${type}" == "minecraft" ]; then
        send_server "say SERVER STOPPING/RESTARTING IN ${default_time} SECONDS"
        sync
        sleep "${default_time}"
        send_server "stop"
    fi
    
    echo -n "Stopping the ${profile} server"
    i=1
    while [ "$i" -le 20 ]; do
        if is_running; then
            echo -n "."
            sleep 1
        else
            break
        fi
        i=$((++i)) 
    done
    echo "."
    if is_running; then
        echo "Server is not shutting down cleanly."
        return 1
    fi

    # Stop the listener if needed
    if [ "${listener}" == "true" ]; then
        listener-stop
    fi
    
    echo "Done."
}

status() {
    if is_running; then
        echo "${profile} server is running"
    else
        echo "${profile} server is shut down"
    fi
}

backup() {
    hash rsync 2>/dev/null || { echo "I need rsync but it's not installed"; exit 1; }
    
    if [ -z "${backup_path}" ]; then
        echo "Backups are disabled for the ${profile} profile."
        echo "Update the profile if you want to make backups."
        return 2
    elif ! is_running && echo "$1" | grep -Eivq "(force|f|-f|override)"; then
        echo "The ${profile} server is not running, so no backups need to be made."
        return 0
    else
        echo "Backing up the ${profile} server..."
    fi
    
    if [ ! -d "${backup_path}" ]; then
        echo "The backup path ${backup_path} for the profile ${profile} does not exist!"
        echo "Creating it now..."
        mkdir "${backup_path}"
    fi 
    
    if is_running; then
        echo "Suspending saves on the ${profile} server..."
        if [ "${type}" == "minecraft" ]; then
            send_server "say SERVER BACKUP STARTING"
            send_server "save-off"
            send_server "save-all"
        fi
        sleep 2
        sync
        sleep 1
    fi
    
    echo "Making the backup..."
    date=$(date "+%Y-%m-%dT%H:%M:%S")
    
    if [ -L "${backup_path}/current" ] && [ -e "${backup_path}/current" ]; then
        echo "Symlink found; making a diff backup"
        rsync -a --link-dest="${backup_path}/current" "${server_path}/" "${backup_path}/back-${date}"
        rm "${backup_path}/current"
    else
        echo "No symlink found; making a clean backup"
        rsync -a "${server_path}/" "${backup_path}/back-${date}"
    fi
    
    ln -s "${backup_path}/back-${date}" "${backup_path}/current"
    
    echo "Backup finished"
    
    if is_running; then
        echo "Re-enabling saves"
        if [ "${type}" == "minecraft" ]; then
            send_server "save-on"
            send_server "say SERVER BACKUP ENDED"
        fi
    fi
    
    echo "Done."
}

say() {
    if ! is_running; then
        echo "The ${profile} server is not running."
        return 2
    fi
    if [ "${type}" == "minecraft" ]; then
        send_server "say $*"
    fi
}

command() {
    if ! is_running; then
        echo "The ${profile} server is not running."
        return 2
    fi
    send_server "$*"
}

update() {
    if [ "${updateable}" == "false" ]; then
        echo "The ${profile} server is not set as updateable"
        return 1
    fi
    
    if [ "${type}" == "minecraft" ]; then
        # Allow for specifiying a specific version
        if [ -n "$1" ]; then
            current_version="$1"
        elif [ "${updateable}" == "vanilla" ]; then
            # Awkward pieces of code that strip the current Minecraft versions from the version file
            current_version=$(wget -q -O - https://s3.amazonaws.com/Minecraft.Download/versions/versions.json |
                                grep "\"release\":" |
                                sed 's/    "release": "\([0-9a-zA-Z.-]\+\)"/\1/' |
                                tr -d '[:space:]')
            echo "The newest stable version is ${current_version}"
        elif [ "${updateable}" == "snapshot" ]; then
            current_version=$(wget -q -O - https://s3.amazonaws.com/Minecraft.Download/versions/versions.json |
                                grep "\"snapshot\":" |
                                sed 's/    "snapshot": "\([0-9a-zA-Z.-]\+\)",/\1/' |
                                tr -d '[:space:]')
            echo "The newest snapshot is ${current_version}"
        else
            echo "Unsupported type of Minecraft release. Please fix this profile"
            return 1
        fi
        
        # Parse the version out of the jar file
        installed_version=$(echo "${jar_name}" |
                            sed 's/minecraft_server.\([0-9a-zA-Z.-]\+\).jar/\1/' |
                            tr -d '[:space:]')
        if [ -n "${installed_version}" ]; then
            echo "Your version is ${installed_version}"
        fi
        
        # Check if the current version is outdated
        if [ "${current_version}" == "${installed_version}" ]; then
            echo "The ${profile} server is up to date"
        else
            if is_running; then
                echo "The ${profile} server is currently running"
                echo -n "Would you like to restart, backup, and update the ${profile} server? [y|N]: "
            else
                echo -n "Would you like to backup and update the ${profile} server? [y|N]: "
            fi
            
            read -r value
            while :; do
                case "${value}" in
                    y|yes|Y)
                        if is_running; then
                            stop || { echo "Server won't shutdown. Aborting."; return 2; }
                            was_running="true"
                        fi
                        cd "${server_path}"
                        
                        echo "Backing up..."
                        backup force || { echo "Backup failed! Quitting..."; return 2; }
                       
                        echo "Updating..."
                        wget "https://s3.amazonaws.com/Minecraft.Download/versions/${current_version}/minecraft_server.${current_version}.jar" ||
                            {   echo "Download failed, aborting"
                                if [ "${was_running}" == "true" ]; then
                                    start || { echo "Server won't start back up!"; return 2; }
                                fi
                                return 1; }
                        chmod +x "minecraft_server.${current_version}.jar"
                        if [ -f "${jar_name}" ]; then
                            rm "${jar_name}"
                        fi
                        if [ ! -d "${server_path}/${world}" ]; then
                            mkdir "${server_path}/${world}"
                        fi
                        echo "The ${profile} server was updated to version ${current_version}"
                        
                        if [ "${was_running}" == "true" ]; then
                            # We updated, so we need our new jar_file
                            load_profile strict
                            start || return 1
                        fi
                        return 0
                    ;;
                    n|no|N)
                        echo "Exiting on user command"
                        return 0
                    ;;
                    *)
                        echo -n "Please enter [y|N]: "
                        read -r value
                esac
            done
        fi
    fi
}

list() {
    echo "Profile list:"
    for profile in "${profile_list[@]}"; do
        echo -n "${profile} "
    done
    echo ""
}

see() {
    if ! is_running; then
        echo "The ${profile} server is not running."
        return 1
    fi
    
    cat > /tmp/screenconfig <<EOF
startup_message off
screen -t 'console' sh -c "tail -n 1000 --follow=name ${server_path}/logs/latest.log"
screen -t 'shell' bash -c "$0 shell ${profile}"
split
focus down
select 'shell'
resize 3
focus up
select 'console'
focus down
EOF
    screen -S "${profile}-console" -c /tmp/screenconfig
    rm /tmp/screenconfig
    screen -S "${profile}-console" -X quit >& /dev/null
}

shell() {
    mode="command"
    while :; do
        if [ "${mode}" == "command" ]; then
            echo -n "c "
        else
            echo -n "s "
        fi
        echo -n "> "
        read -r value
        set -- ${value}
        case "$1" in
            exit|:q|quit)
                screen -S "${profile}-console" -X quit >& /dev/null
                return 0
            ;;
            nick)
                shift 1
                nick="$*"
            ;;
            help)
                echo "c|s|exit|nick|help"
            ;;
            c|command)
                shift 1
                # Only send something if line is not blank
                if [ -n "$*" ]; then
                    send_server "$*"
                fi
                mode="command"
            ;;
            s|say|chat)
                shift 1
                mode="say"
            ;&
            *)
                # Only send something if line is not blank
                if [ -n "$*" ]; then
                    if [ "${mode}" == "command" ]; then
                        send_server "$*"
                    else
                        if [ -n "${nick}" ]; then
                            send_server "say <${nick}> $*"
                        else
                            send_server "say $*"
                        fi
                    fi
                fi
        esac
    done
}

listener-start() {
    screen -dmS "${profile}-listener" $0 listener "${profile}" &
}

listener-stop() {
    screen -S "${profile}-listener" -X quit >& /dev/null
}

new() {
    # Add new profile to config
    if [ ! "$1" ] || [ "$1" == "minecraft" ] || [ "$1" == "vanilla" ]; then
        cat >> "${CONFIG_FILE}" <<'EOF'
vanilla() {
    type="minecraft"
    autostart="true"
    backup_path="/${server_root}/backup/${profile}Minecraft"
    world="world"
    find_jar
    server_command="${java} -Xmx4G -Xms2G -jar ${jar_name} nogui"
    updateable="vanilla"
}

EOF
        echo "New vanilla minecraft profile added."
    elif [ "$1" == "modded" ]; then
        cat >> "${CONFIG_FILE}" <<'EOF'
modded() {
    type="minecraft"
    autostart="false"
    backup_path="/${server_root}/backup/${profile}Minecraft"
    world="world"
    jar_name="forge-1.7.10-10.13.4.1448-1.7.10-universal.jar"
    server_command="${java} -Xmx4G -Xms2G -cp ${jar_name} cpw.mods.fml.relauncher.ServerLaunchWrapper nogui"
    updateable="false"
}

EOF
        echo "New modded minecraft profile added."
    else
        echo "Unknown profile type ${1}."
        return 1
    fi
    echo "Add the new profile to the profile list to activate it."
}

config() {
    # Make sure GNU screen is installed
    hash screen 2>/dev/null || { echo >&2 "I need screen but it's not installed"; exit 1; }
    
    if [ ! -d "/home/${USERNAME}/.config" ]; then
        mkdir "/home/${USERNAME}/.config"
    fi
    if ! [ -e "${CONFIG_FILE}" ]; then
        touch "${CONFIG_FILE}"
        cat > "${CONFIG_FILE}" <<'EOF'
# Time for stopping and restarting. Set this if you want a different wait.
#default_time=5

# Root of all Minecraft servers. This does not have to be specified if you want
# to specify each server_path by itself. If you do specify this, you can leave
# each server_path blank, and it will default to server_root/profile_name.
server_root="/var/minecraft"

# Location of the universal whitelist/oplist. Leave blank if you want to use
# seperate ones for each server.
#player_list_path="${server_root}"

# This is agreeing to the Mojang EULA, not mine. See their EULA here:
# https://account.mojang.com/documents/minecraft_eula
# Changing this to true will make all servers EULA be true.
#eula="true"

# The java binary to use. Set this if the default java ("which java") isn't
# what you want to run the servers.
#java="java"

# Profiles
# To make your own, run "console new <type>"
# Exceptable profiles types are "minecraft", for now.
# To disable backups, leave the 'backup_path' blank, eg: backup_path=""
# 'updateable' can equal types "vanilla" or "snapshot" for minecraft.
# "false" will disable updating.
# find_jar is a search that finds the minecraft jar file in the server folder, allowing for updates
# without changing this config file. If there is more than one minecraft jar file in the folder
# the search will fail

# The list of servers that the "all" commands will use
profile_list=()

EOF
        echo "Base config created. Run \"$0 new <type>\" to add your first profile."
        return 0
    fi
    
    if [ -z "$EDITOR" ]; then
        vi "${CONFIG_FILE}" || return $?
    else
        "${EDITOR}" "${CONFIG_FILE}" || return $?
    fi
    
    # Load the configuration to check it
    echo "Checking new config..."
    source "${CONFIG_FILE}"
    
    for profile in "${profile_list[@]}"; do
        defaults
        ${profile} >& /dev/null || { echo "Profile ${profile} was not found, but it was in the profile list."; return 1; }
        check_config
    done
    echo "Config looks good."
}

help_text() {
    # Help text
    echo "Java server script version $VERSION by Rycieos"
    echo "Usage: $0 [start|stop|restart|try-restart|backup|say|command|status|update|see|listener-start|listener-stop|listener-restart|list|config|new] <profile-name>|all "
    echo "Profile settings are at ~/.config/java_console.config. Use $0 config to edit"
    exit 1
}

load_profile() {
    if [ -z "${profile}" ]; then
        echo "No Profile specified"
        help_text
    fi
    # Load the profile's settings by calling it as a function
    defaults
    ${profile} >& /dev/null || { echo "Profile ${profile} was not found. Run \"$0 new <type>\" to add it"; exit 1; }
    check_config "$1"
}

# SCRIPT START

SWITCH="$1"

if [ ! -e "${CONFIG_FILE}" ] && [ "$1" != "config" ]; then
    echo "No config file was found!"
    echo "Please run \"$0 config\""
    exit 1
elif [ "${SWITCH}" != "config" ] && [ "${SWITCH}" != "new" ] && [ "${SWITCH}" != "add" ]; then
    # Load the configuration only if we aren't trying to change it
    source "${CONFIG_FILE}"
fi

if [ "$2" == "all" ]; then
    case "${SWITCH}" in
        start|s)
            for profile in "${profile_list[@]}"; do
                load_profile strict
                start auto
            done
            exit 0
        ;;
        stop|restart|backup|say|command)
            # Shift to get rid of the <command> all. The remainder gets run
            shift 2
            for profile in "${profile_list[@]}"; do
                load_profile strict
                "${SWITCH}" "$@"
            done
            exit 0
        ;;
        status|update)
            # Shift to get rid of the <command> all. The remainder gets run
            shift 2
            for profile in "${profile_list[@]}"; do
                load_profile
                "${SWITCH}" "$@"
            done
            exit 0
        ;;
        see|console)
            echo "$1 is not supported for all profiles at the same time."
            exit 3
        ;;
        config|new|add)
            echo "all is implied for ${1}."
            exit 3
        ;;
    esac
fi

profile="$2"

case "${SWITCH}" in
    start)
        load_profile strict
        start "$3"
    ;;
    stop)
        load_profile strict
        stop "$3"
    ;;
    restart)
        load_profile strict
        stop "$3"
        start "$3"
    ;;
    try-restart)
        load_profile strict
        if is_running; then
            stop "$3" && start "$3"
        fi
    ;;
    status)
        load_profile
        status
    ;;
    backup)
        load_profile strict
        backup "$3"
    ;;
    say)
        load_profile strict
        shift 2
        say "$*"
    ;;
    command)
        load_profile strict
        shift 2
        command "$*"
    ;;
    update)
        load_profile
        update "$3"
    ;;
    see|console)
        load_profile strict
        see
    ;;
    shell)
        load_profile
        shell
    ;;
    listener)
        load_profile
        . minecraft-listener console
    ;;
    listener-start)
        load_profile
        listener-start
    ;;
    listener-stop)
        listener-stop
    ;;
    listener-restart)
        load_profile
        listener-stop
        listener-start
    ;;
    # Profile agnostic
    list)
        list
    ;;
    new)
        new "$2"
    ;;
    config)
        config
    ;;
    *)
        help_text
esac
exit $?
